"""
    %run "C:\Users\simon.hughes\Dropbox\PhD\Code\NLP Library\PyDevNLPLibrary\src\CodeGen\\ClassFromCsv"
"""
from datetime import date

def generate(classname, jobs_file, delim = "|", to_ignore = None):
    
    if to_ignore == None:
        to_ignore = []
        
    def BOOL(b = "False"):
        if b == "True" or b == "False":
            return bool(b)
        raise Exception("Not a bool")
        
    type_fns = [BOOL, int, float, str]
    types = [type(f()) for f in type_fns]
    
    type2id = dict([(v,k) for k,v in enumerate(types)])
    id2fn = dict([(i,f) for i,f in enumerate(type_fns)])
    
    def get_line(f):
        return f.readline().strip().lower().split(delim)
        
    def try_parse(val, lmbda):
        try:
            return lmbda(val)
        except:
            return None
    
    def get_type(val):
        clean = "".join([c for c in val if c not in to_ignore])
        for fn in type_fns:
            parsed = try_parse(clean, fn)
            if parsed != None:
                return type2id[ type(fn()) ]
        return type2id[ type(str()) ]
    
    with open(jobs_file, "r+") as f:
        lines = []
        
        header = get_line(f)
        while len(lines) < 500:
            tokens = get_line(f)
            if len(tokens) == 0 or tokens == None:
                break
            lines.append(tokens)
        
    """ Figure out the most restrictive type that can parse the data for the col """
    col_types = map(get_type, lines[0])
    
    assert len(header) == len(col_types)
    for line in lines[1:]:
        for i,tok in enumerate(line):
            col_types[i] = max(col_types[i], get_type(tok))
    
    col_fns = map(lambda id: id2fn[id], col_types )
    col_with_type = zip( header, col_fns )
    
    code = "#Auto-generated by ClassFromCsv on '{0}'\n\n".format(str(date.today()))
    code += "class {0}(object): \n".format(classname)
    code += "    ignore = set(" + str(to_ignore) + ")\n"
    code += "\n    def __init__(self, tokens): \n"
    
    for i, (col, fn) in enumerate(col_with_type):
        if len(to_ignore) > 0:
            code += "\n        self.{0} = {1}(self.remove_chars(tokens[{2}]))".format(col, str(fn)[7:-2].lower(), str(i))
        else:
            code += "\n        self.{0} = {1}(tokens[{2}])".format(col, str(fn)[7:-2].lower(), str(i))
    code += "\n\n"
    
    if len(to_ignore) > 0:
        code += "\n    def remove_chars(self, input):\n        return ''.join([c for c in input if c not in {0}.ignore])".format(classname)
    return (code, header, col_fns)
